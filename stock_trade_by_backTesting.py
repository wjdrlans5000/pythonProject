# backtesting_1002_fixed.py
import pandas as pd
import yfinance as yf
from backtesting import Backtest, Strategy
import requests
import datetime
import os
import matplotlib.pyplot as plt
import platform
import io
import matplotlib
matplotlib.use("Agg")  # GUI ÏóÜÎäî ÌôòÍ≤ΩÏóêÏÑúÎèÑ ÏïàÏ†ÑÌïòÍ≤å Î†åÎçîÎßÅ

# ==========================
# üß© Ìè∞Ìä∏ ÏÑ§Ï†ï (Ï†ÑÏó≠)
# ==========================
if platform.system() == "Windows":
    plt.rcParams['font.family'] = 'Malgun Gothic'
elif platform.system() == "Darwin":  # macOS
    plt.rcParams['font.family'] = 'AppleGothic'
else:
    plt.rcParams['font.family'] = 'NanumGothic'

plt.rcParams['axes.unicode_minus'] = False


def load_telegram_config(config_path="telegram_config.txt"):
    """
    Í∞ôÏùÄ Í≤ΩÎ°úÏùò telegram_config.txt ÌååÏùºÏóêÏÑú BOT_TOKENÍ≥º CHAT_IDÎ•º ÏùΩÏñ¥Ïò¥
    """
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"‚ö†Ô∏è ÏÑ§Ï†ï ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {config_path}")

    bot_token = None
    chat_id = None

    with open(config_path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):  # Ï£ºÏÑùÏù¥ÎÇò Í≥µÎ∞± Î¨¥Ïãú
                continue
            if line.startswith("BOT_TOKEN="):
                bot_token = line.split("=", 1)[1].strip()
            elif line.startswith("CHAT_ID="):
                chat_id = line.split("=", 1)[1].strip()

    if not bot_token or not chat_id:
        raise ValueError("‚ö†Ô∏è ÏÑ§Ï†ï ÌååÏùºÏóê BOT_TOKEN ÎòêÎäî CHAT_IDÍ∞Ä ÏóÜÏäµÎãàÎã§.")

    return bot_token, chat_id

# ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ° Ìï®Ïàò
def send_telegram_message(bot_token, chat_id, text, photo=None):
    base_url = f"https://api.telegram.org/bot{bot_token}"
    if photo:
        url = f"{base_url}/sendPhoto"
        files = {'photo': photo}
        data = {'chat_id': chat_id, 'caption': text}
        response = requests.post(url, files=files, data=data)
    else:
        url = f"{base_url}/sendMessage"
        data = {'chat_id': chat_id, 'text': text}
        response = requests.post(url, data=data)

    # Í≤∞Í≥º ÌôïÏù∏Ïö© Î°úÍ∑∏ Ï∂îÍ∞Ä
    print("üì§ Telegram response:", response.status_code, response.text)
    return response.json()


# ----------------------------
# MACD & Signal Í≥ÑÏÇ∞ Ìï®Ïàò
# ----------------------------
def compute_macd(df, short=12, long=26, signal=9):
    df['EMA_short'] = df['Close'].ewm(span=short, adjust=False).mean()
    df['EMA_long'] = df['Close'].ewm(span=long, adjust=False).mean()
    df['MACD'] = df['EMA_short'] - df['EMA_long']
    df['Signal'] = df['MACD'].ewm(span=signal, adjust=False).mean()
    df['MACD_prev'] = df['MACD'].shift(1)
    df['Signal_prev'] = df['Signal'].shift(1)
    return df

# ----------------------------
# Î≥ºÎ¶∞Ï†ÄÎ∞¥Îìú Í≥ÑÏÇ∞ Ìï®Ïàò
# ----------------------------
def compute_bollinger(df, window=20, num_std=2):
    df['BB_MID'] = df['Close'].rolling(window).mean()
    df['BB_STD'] = df['Close'].rolling(window).std()
    df['BB_UPPER'] = df['BB_MID'] + num_std * df['BB_STD']
    df['BB_LOWER'] = df['BB_MID'] - num_std * df['BB_STD']
    return df

# RSI Í≥ÑÏÇ∞
def compute_rsi(df, window=14):
    delta = df['Close'].diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.ewm(span=window, adjust=False).mean()
    avg_loss = loss.ewm(span=window, adjust=False).mean()
    rs = avg_gain / avg_loss
    df['RSI'] = 100 - (100 / (1 + rs))
    return df

# ADX Í≥ÑÏÇ∞
# ADX + DI Í≥ÑÏÇ∞
def compute_adx(df, window=14):
    high = df['High']
    low = df['Low']
    close = df['Close']

    tr1 = high - low
    tr2 = abs(high - close.shift(1))
    tr3 = abs(low - close.shift(1))
    df['TR'] = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    df['ATR'] = df['TR'].ewm(span=window, adjust=False).mean()

    up_move = high.diff()
    down_move = low.diff() * -1

    plus_dm = up_move.where((up_move > 0) & (up_move > down_move), 0)
    minus_dm = down_move.where((down_move > 0) & (down_move > up_move), 0)

    df['PDI'] = (plus_dm.ewm(span=window, adjust=False).mean() / df['ATR']) * 100
    df['MDI'] = (minus_dm.ewm(span=window, adjust=False).mean() / df['ATR']) * 100
    df['ADX'] = (abs(df['PDI'] - df['MDI']) / (df['PDI'] + df['MDI'])).ewm(span=window, adjust=False).mean() * 100

    return df

# Ïù¥ÎèôÌèâÍ∑†ÏÑ† Í∏∞Ïö∏Í∏∞ Ï∂îÍ∞Ä
def compute_ma_slope(df, window=20):
    df['MA'] = df['Close'].rolling(window).mean()
    df['MA_SLOPE'] = df['MA'].diff()
    return df

# ----------------------------
# Strategy (Îç∞Ïù¥ÌÑ∞ÌîÑÎ†àÏûÑÏóêÏÑú Í≥ÑÏÇ∞Îêú ÏßÄÌëú ÏÇ¨Ïö©)
# ----------------------------
class MultiIndicatorStrategy(Strategy):
    window_days = 20
    adx_threshold = 20

    def init(self):
        # int(self.equity / self.data.Close[-1]) # cash ÎÇ¥ Íµ¨Îß§Í∞ÄÎä• ÏàòÎüâ
        # Î∞±ÌÖåÏä§Ìä∏Ïö© Ï†ÑÏ≤¥ dfÏóêÏÑú ÎßàÏßÄÎßâÎÇ† Í∏∞Î°ù
        self._last_day = self.data.index[-1]

        # Í∞ÄÍ≤©/ÏßÄÌëú(Îç∞Ïù¥ÌÑ∞ÌîÑÎ†àÏûÑÏóê Ïù¥ÎØ∏ Í≥ÑÏÇ∞ÎêòÏñ¥ ÏûàÏñ¥Ïïº Ìï®)
        self.close    = self.I(lambda x: x, self.data.Close)
        self.macd     = self.I(lambda x: x, self.data.MACD)
        self.signal   = self.I(lambda x: x, self.data.Signal)

        self.bb_mid   = self.I(lambda x: x, self.data.BB_MID)
        self.bb_upper = self.I(lambda x: x, self.data.BB_UPPER)
        self.bb_lower = self.I(lambda x: x, self.data.BB_LOWER)

        self.rsi      = self.I(lambda x: x, self.data.RSI)
        self.ma_slope = self.I(lambda x: x, self.data.MA_SLOPE)

        # ADX Í≥ÑÏó¥ (PDI/MDI/ADX) ‚Äî Î∞òÎìúÏãú dfÏóê PDI,MDI,ADX Ïª¨ÎüºÏù¥ ÏûàÏñ¥Ïïº Ìï®
        self.pdi      = self.I(lambda x: x, self.data.PDI)
        self.mdi      = self.I(lambda x: x, self.data.MDI)
        self.adx      = self.I(lambda x: x, self.data.ADX)
        self.ema_short      = self.I(lambda x: x, self.data.EMA_short)
        self.ema_long      = self.I(lambda x: x, self.data.EMA_long)

        self.pending_buy = None
        self.pending_sell = None
        self.trade_logs = []

    # Ìó¨Ìçº: Ï∂îÏÑ∏ÌåêÎã® (Ïù∏Îç±Ïä§Îäî ÏùåÏàò Ïù∏Îç±Ïä§Î°ú ÏÇ¨Ïö© Í∞ÄÎä•)
    def is_uptrend(self, idx):
        try:
            return (self.adx[idx] >= self.adx_threshold) and (self.pdi[idx] > self.mdi[idx]) and \
                ((self.ema_short[idx] > self.ema_long[idx]) or (self.ma_slope[idx] > 0))
        except Exception:
            return False

    def is_downtrend(self, idx):
        try:
            margin = 3
            return (self.adx[idx] >= self.adx_threshold) and (self.mdi[idx] >= self.pdi[idx] + margin) and \
                ((self.ema_short[idx] < self.ema_long[idx]) or (self.ma_slope[idx] < 0)) and \
                (self.close[idx] < self.ema_short[idx])
        except Exception:
            return False

    def next(self):
        # ÏïàÏ†ÑÌïòÍ≤å Ïù¥Ï†Ñ Î∞è ÌòÑÏû¨ Í∞í ÏñªÍ∏∞
        try:
            i0 = -1  # today
            i1 = -2  # yesterday
            macd_prev = float(self.macd[i1])
            sig_prev  = float(self.signal[i1])
            macd_now  = float(self.macd[i0])
            sig_now   = float(self.signal[i0])
            is_box = not (self.is_downtrend(i0) or self.is_uptrend(i0))
        except Exception:
            return

        # Îß§Ïàò Ïã†Ìò∏: MACD Í≥®Îì† ÌÅ¨Î°úÏä§ Í∞êÏßÄ -> pending_buy ÏÑ§Ï†ï
        if (not self.position or self.position.is_short) and (macd_prev <= sig_prev) and (macd_now > sig_now):
            self.pending_buy = {'remaining': self.window_days, 'reason_signal': 'MACDÍ≥®Îì†ÌÅ¨Î°úÏä§'}
            # print({'self.pending_buy': self.pending_buy
            #           ,'ÎãπÏùºÏ¢ÖÍ∞Ä' : self.close[i0]
            #           ,'time': self.data.index[-1]})
            # Ï¶âÏãú ÎèôÏùºÏùº ÏßÑÏûÖ Í∞ÄÎä•ÏÑ± Ï≤¥ÌÅ¨ (MACD 0 ÎèåÌåå or BB ÎèåÌåå)
            try:
                if macd_now >= 0 and self.is_uptrend(i0):
                    size = int(self.equity / self.data.Close[-1])
                    if size > 0:
                        self.buy(size=size)
                        self.trade_logs.append(('BUY', 'UPTREND_MACD0_UP', self.data.index[-1], self.close[-1]))
                        self.pending_buy = None
                    return
                if (self.close[i0] > self.bb_mid[i0]) and (self.close[i1] <= self.bb_mid[i1]) and not self.is_downtrend(i0):
                    size = int(self.equity / self.data.Close[-1])
                    if size > 0:
                        self.buy(size=size)
                        self.trade_logs.append(('BUY', 'BB_UP', self.data.index[-1], self.close[-1]))
                        self.pending_buy = None
                    return
            except Exception:
                pass
            # try:
            #     if (self.close[i0] > self.bb_mid[i0]) and (self.close[i1] <= self.bb_mid[i1]) and (not self.is_downtrend(i0)):
            #         size = int(self.equity / self.data.Close[-1])
            #         if size > 0:
            #             self.buy(size=size)
            #             self.trade_logs.append(('BUY', 'BB_UP', self.data.index[-1], self.close[-1]))
            #             self.pending_buy = None
            #         return
            # except Exception:
            #     pass
        # TODO Î∞ïÏä§Í∂å ÏùºÎïå BB ÌïòÎã® Î∞¥Îìú ÏÉÅÏäπ ÎèåÌååÏãú Îß§Ïàò, BB ÏÉÅÎã® ÎèÑÎã¨Ïãú Îß§ÎèÑ
        # Îß§Ïàò ÌñàÎäîÎç∞ Î∞ïÏä§Í∂å ÏÉÅÎã® ÎèÑÎã¨ Î™ªÌïòÍ≥† Îã§Ïãú BB ÌïòÎã® Î∞¥Îìú ÎèÑÎã¨Ïãú Îß§ÎèÑ
        # if (not self.position or self.position.is_short) and is_box:
        #     try:
        #         if (self.close[i0] > self.bb_lower[i0]) and (self.close[i1] <= self.bb_lower[i1]):
        #             size = int(self.equity / self.data.Close[-1])
        #             if size > 0:
        #                 self.buy(size=size)
        #                 self.trade_logs.append(('BUY', 'BOX_BB_LOWER_UP', self.data.index[-1], self.close[-1]))
        #                 self.pending_buy = None
        #         return
        #     except Exception:
        #         pass

        # Îß§ÎèÑ Ïã†Ìò∏: MACD Îç∞ÎìúÌÅ¨Î°úÏä§ Í∞êÏßÄ -> pending_sell ÏÑ§Ï†ï
        if self.position.is_long and (macd_prev >= sig_prev) and (macd_now < sig_now):
            self.pending_sell = {'remaining': self.window_days, 'reason_signal': 'MACDÎç∞ÎìúÌÅ¨Î°úÏä§'}
            # print({'self.pending_sell': self.pending_sell
            #           ,'time': self.data.index[-1]})
            # Ï¶âÏãú Ï°∞Í±¥ Ï≤¥ÌÅ¨
            try:
                if (macd_now < 0) and (self.macd[i1] >= 0) and self.is_uptrend(i0):
                    # self.sell() # ÏñòÎäî Îß§ÎèÑÏôÄ ÎèôÏãúÏóê ÏàèÌè¨ÏßÄÏÖò Ïû°Ïùå
                    self.position.close() # ÏñòÎäî Ï≤≠ÏÇ∞Îßå
                    self.trade_logs.append(('SELL', 'MACD0_DOWN', self.data.index[-1], self.close[-1]))
                    self.pending_sell = None
                    return
            except Exception:
                pass
            try:
                if (self.close[i1] >= self.bb_mid[i1]) and (self.close[i0] < self.bb_mid[i0]) and not self.is_uptrend(i0):
                    self.position.close()
                    self.trade_logs.append(('SELL', 'BB_DOWN', self.data.index[-1], self.close[-1]))
                    self.pending_sell = None
                    return
                if self.rsi[i0] > 72 and not self.is_uptrend(i0):
                    self.position.close()
                    self.trade_logs.append(('SELL', 'RSI_OVER', self.data.index[-1], self.close[-1]))
                    self.pending_sell = None
                    return
            except Exception:
                pass

        # TODO Î∞ïÏä§Í∂å ÏùºÎïå BB ÏÉÅÎã® ÎèÑÎã¨Ïãú Îß§ÎèÑ
        # if self.position.is_long and is_box:
        #     try:
        #         if (self.close[i0] >= self.bb_upper[i0]) and (self.close[i1] < self.bb_upper[i1]):
        #             self.position.close()
        #             self.trade_logs.append(('SELL', 'BOX_BB_UPPER_UP', self.data.index[-1], self.close[-1]))
        #             self.pending_sell = None
        #         return
        #     except Exception:
        #         pass


        # pending_buy Ï≤¥ÌÅ¨
        # ÎãπÏùºÏóî Î≥¥Ï°∞ Ï°∞Í±¥Ïù¥ Ïïà ÎßûÏïÑÏÑú ÏßÑÏûÖ Ïã§Ìå®ÌñàÎã§Î©¥, self.pending_buyÍ∞Ä ÏÇ¥ÏïÑÏûàÏùå.
        # Ïù¥ÌõÑ ÏµúÎåÄ window_days (20Ïùº) ÎèôÏïà ÏßÄÏºúÎ≥¥Îã§Í∞Ä
        # Ï°∞Í±¥(Ïòà: MACD 0ÏÑ† ÎèåÌåå, BB ÏÉÅÌñ• ÎèåÌåå, RSI Ï†ÄÏ†ê Î∞òÎì± Îì±)Ïù¥ ÎÇòÏò§Î©¥ Îß§Ïàò Ï≤¥Í≤∞.
        if self.pending_buy is not None:
            self.pending_buy['remaining'] -= 1
            # print({'self.remaining': self.pending_buy['remaining']
            #           ,'is_uptrend(i0)':self.is_uptrend(i0)
            #           ,'is_downtrend(i0)':self.is_downtrend(i0)
            #           ,'ÎãπÏùº.macd[i0]': self.macd[i0]
            #           ,'Ï†ÑÏùº.macd[i1]': self.macd[i1]
            #           ,'ÎãπÏùºÏ¢ÖÍ∞Ä' : self.close[i0]
            #           ,'ÎãπÏùº BB_MID' : self.bb_mid[i0]
            #           ,'time': self.data.index[i0]
            #        })
            try:
                # Mmacd 0 ÎèåÌååÎäî ÏÉÅÏäπÏ∂îÏÑ∏ ÏïÑÎãàÏñ¥ÎèÑ Ï†ÅÏö©
                if (self.macd[i0] >= 0) and (self.macd[i1] < 0) : # and self.is_uptrend(i0)
                    size = int(self.equity / self.data.Close[-1])
                    if size > 0:
                        self.buy(size=size)
                        self.trade_logs.append(('BUY', 'MACD0_UP_pending', self.data.index[-1], self.close[-1]))
                        self.pending_buy = None
                    return
                # macd Îç∞Îìú ÌÅ¨Î°úÏä§ Ïã†Ìò∏ Î∞úÏÉùÌïòÏßÄ ÏïäÏïòÏùÑÎïå BB ÎèåÌåå Îß§Ïàò ÏßÑÌñâ ÏÉÅÏäπÏ∂îÏÑ∏ÏùºÎïåÎßå
                if ((macd_now >= sig_now) and (self.close[i0] > self.bb_mid[i0]) and (self.close[i1] <= self.bb_mid[i1])
                        and self.is_uptrend(i0)):
                    size = int(self.equity / self.data.Close[-1])
                    if size > 0:
                        self.buy(size=size)
                        self.trade_logs.append(('BUY', 'BB_UP_pending', self.data.index[-1], self.close[-1]))
                        self.pending_buy = None
                    return
                if (self.rsi[i0] < 30) and (not self.is_downtrend(i0)):
                    size = int(self.equity / self.data.Close[-1])
                    if size > 0:
                        self.buy(size=size)
                        self.trade_logs.append(('BUY', 'RSI_box_pending', self.data.index[-1], self.close[-1]))
                        self.pending_buy = None
                    return
            except Exception:
                pass
            if self.pending_buy['remaining'] <= 0:
                self.pending_buy = None

        # pending_sell Ï≤¥ÌÅ¨
        if self.pending_sell is not None:
            self.pending_sell['remaining'] -= 1
            # print({'self.remaining': self.pending_sell['remaining']
            #           ,'is_uptrend(i0)':self.is_uptrend(i0)
            #           ,'ÎãπÏùº.macd[i0]': self.macd[i0]
            #           ,'Ï†ÑÏùº.macd[i1]': self.macd[i1]
            #           ,'ÎãπÏùºÏ¢ÖÍ∞Ä' : self.close[i0]
            #           ,'ÎãπÏùº BB_MID' : self.bb_mid[i0]
            #           ,'time': self.data.index[i0]
            #        })
            try:
                if self.is_uptrend(i0):
                    if (self.macd[i0] < 0) and (self.macd[i1] >= 0):
                        self.position.close()
                        self.trade_logs.append(('SELL', 'UPTREND_MACD0_DOWN_pending', self.data.index[-1], self.close[-1]))
                        self.pending_sell = None
                        return
                # 5ÏùºÏó∞ÏÜç ÌïòÎùΩÏû•ÏùºÎïå Î¨¥Ï°∞Í±¥ Îß§ÎèÑ Ïú†ÎèÑ
                elif self.is_downtrend(0) and self.is_downtrend(-1) and self.is_downtrend(-2) and self.is_downtrend(-3) and self.is_downtrend(-4) :
                    if self.macd[i0] < 0 :
                        self.position.close()
                        self.trade_logs.append(('SELL', 'DOWNTREND_MACD0_DOWN_pending', self.data.index[-1], self.close[-1]))
                        self.pending_sell = None
                        return
                    if self.close[i0] < self.bb_mid[i0] : # and (self.close[i1] >= self.bb_mid[i1])
                        self.position.close()
                        self.trade_logs.append(('SELL', 'DOWNTREND_BB_DOWN_pending', self.data.index[-1], self.close[-1]))
                        self.pending_sell = None
                        return
                else:
                    if (self.macd[i0] < 0) and (self.macd[i1] >= 0) : #
                        self.position.close()
                        self.trade_logs.append(('SELL', 'MACD0_DOWN_pending', self.data.index[-1], self.close[-1]))
                        self.pending_sell = None
                        return
                    if (self.close[i0] < self.bb_mid[i0]) and (self.close[i1] >= self.bb_mid[i1]) : #
                        self.position.close()
                        self.trade_logs.append(('SELL', 'BB_DOWN_pending', self.data.index[-1], self.close[-1]))
                        self.pending_sell = None
                        return
                    if self.rsi[i0] > 72:
                        self.position.close()
                        self.trade_logs.append(('SELL', 'RSI_pending', self.data.index[-1], self.close[-1]))
                        self.pending_sell = None
                        return
            except Exception:
                pass
            if self.pending_sell['remaining'] <= 0:
                self.pending_sell = None

        # ÎßàÏßÄÎßâÎÇ† Í∞ïÏ†ú Ï≤≠ÏÇ∞ (Ïò§Îäò ÎÇ®ÏïÑ ÏûàÎäî Ìè¨ÏßÄÏÖòÎßå)
        if self.data.index[i0] == self._last_day:
            if self.position and self.position.is_long:

                self.position.close()
                self.trade_logs.append(('FINAL_CLOSE', 'FINAL_CLOSE', self.data.index[i0], self.close[i0]))
                return

# ----------------------------
# Ïã§Ìñâ: yfinance ‚Üí ÏßÄÌëú Í≥ÑÏÇ∞ ‚Üí backtest
# ----------------------------
if __name__ == "__main__":
    BOT_TOKEN, CHAT_ID = load_telegram_config()
    symbols = [
        # üá∫üá∏ ÎØ∏Íµ≠ Ï¢ÖÎ™©
        "TSLA/Tesla",
        "TEM/Tempest Therapeutics",
        "NVDA/NVIDIA",
        "ORCL/Oracle",
        "QQQ/Invesco QQQ Trust",
        "SPY/SPDR S&P 500 ETF",
        "FIG/Figure Acquisition Corp",
        "MSFT/Microsoft",
        "META/Meta Platforms",
        "AMZN/Amazon",
        "GOOGL/Alphabet",
        "TSM/Taiwan Semiconductor",
        "AAPL/Apple",
        "IONQ/IONQ Inc",
        "AVGO/Broadcom",

        # üá∞üá∑ ÌïúÍµ≠ Ï¢ÖÎ™©
        "005930.KS/ÏÇºÏÑ±Ï†ÑÏûê",
        "000660.KS/SKÌïòÏù¥ÎãâÏä§",
        "373220.KS/LGÏóêÎÑàÏßÄÏÜîÎ£®ÏÖò",
        "035420.KS/NAVER",
        "015760.KS/ÌïúÍµ≠Ï†ÑÎ†•",
        "302440.KS/SKÎ∞îÏù¥Ïò§ÏÇ¨Ïù¥Ïñ∏Ïä§",
        "247540.KS/ÏóêÏΩîÌîÑÎ°úÎπÑÏó†",
        "005490.KS/POSCOÌôÄÎî©Ïä§",
        "005380.KS/ÌòÑÎåÄÏ∞®",
        "105560.KS/KBÍ∏àÏúµ",
        "086790.KS/ÌïòÎÇòÍ∏àÏúµÏßÄÏ£º",
        "034020.KS/ÎëêÏÇ∞ÏóêÎÑàÎπåÎ¶¨Ìã∞",
        "012450.KS/ÌïúÌôîÏóêÏñ¥Î°úÏä§ÌéòÏù¥Ïä§",
        "267250.KS/HDÌòÑÎåÄ",
        "402340.KS/SKÏä§ÌÄòÏñ¥",
        "006400.KS/ÏÇºÏÑ±SDI",
        "051910.KS/LGÌôîÌïô",
        "035720.KS/Ïπ¥Ïπ¥Ïò§",
        "196170.KS/ÏïåÌÖåÏò§Ï††",
        "068270.KS/ÏÖÄÌä∏Î¶¨Ïò®",
        "329180.KS/HDÌòÑÎåÄÏ§ëÍ≥µÏóÖ",
        "042660.KS/ÌïúÌôîÏò§ÏÖò"
    ]
    # symbol = "TSLA"
    # symbol = "005930.KS"
    start = "2023-01-01"   # Ïã§Ï†ú Î∂ÑÏÑù ÏãúÏûëÎ≥¥Îã§ ÏµúÏÜå 2Îã¨ Ïïû
    end   = datetime.datetime.today().strftime("%Y-%m-%d")

    results = []  # Ï†ÑÏ≤¥ Í≤∞Í≥º Ï†ÄÏû•Ïö©

    for s in symbols:
        symbol, name = s.split("/")
        print(f"\nüìà === {name} Î∞±ÌÖåÏä§Ìä∏ ÏãúÏûë ===")

        # Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú
        df = yf.download(symbol, start=start, end=end, group_by="column", auto_adjust=False)
        df.columns = df.columns.droplevel(1)

        # backtestingÏù¥ Í∏∞ÎåÄÌïòÎäî Ïª¨ÎüºÎ™Ö Î≥¥Ïû•
        df = df.rename(columns={'Open': 'Open', 'High': 'High', 'Low': 'Low', 'Close': 'Close', 'Volume': 'Volume'})
        df = df.dropna().copy()

        # === Ïó¨Í∏∞ÏÑú ÏßÄÌëúÎ•º Ï†ÑÏ≤¥ DF Í∏∞Ï§ÄÏúºÎ°ú Î®ºÏ†Ä Í≥ÑÏÇ∞ ===
        # MACD + Bollinger Í≥ÑÏÇ∞
        df = compute_macd(df, short=12, long=26, signal=9)
        df = compute_bollinger(df, window=20, num_std=2)
        df = compute_rsi(df, window=14)
        df = compute_adx(df, window=14)
        df = compute_ma_slope(df, window=20)

        # Ïã§Ï†ú ÌÖåÏä§Ìä∏ Íµ¨Í∞Ñ (ÏßÄÌëú ÏïàÏ†ïÌôî Ïù¥ÌõÑ)
        df = df.loc["2023-10-02":].dropna().copy()
        print(df.head())

        # Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ
        bt = Backtest(df, MultiIndicatorStrategy, cash=1000000, commission=0,
                      exclusive_orders=True, finalize_trades=True, trade_on_close=True)
        stats = bt.run()

        # BUY/SELL/FINAL_CLOSE Íµ¨Î∂ÑÏö©
        logs = getattr(stats._strategy, "trade_logs", [])
        trade_df = pd.DataFrame(logs, columns=["Signal", "Reason", "Date", "Price"]) if logs else pd.DataFrame()
        if not trade_df.empty:
            real_trades = trade_df[trade_df["Signal"].isin(["BUY", "SELL"])].shape[0]
            has_final_close = "FINAL_CLOSE" in trade_df["Signal"].values
            last_log = trade_df.iloc[-1].to_dict()
            last_log_str = f"{last_log['Signal']} ({last_log['Reason']}) @ {last_log['Date'].strftime('%Y-%m-%d')} ${round(float(last_log['Price']),2)}"
        else:
            real_trades = 0
            has_final_close = False
            last_log_str = "None"


        # Í≤∞Í≥º ÏöîÏïΩ Ï†ÄÏû•
        result = {
            "Symbol": symbol,
            "name": name,
            "Start": df.index[0].strftime("%Y-%m-%d"),
            "End": df.index[-1].strftime("%Y-%m-%d"),
            "Final Equity": round(stats["Equity Final [$]"], 2),
            "Return [%]": round(stats["Return [%]"], 2),
            "Buy & Hold Return [%]": round(stats["Buy & Hold Return [%]"], 2),
            "Win Rate [%]": round(stats["Win Rate [%]"], 2),
            "Trades": int(stats["# Trades"]),
            "Best Trade [%]": round(stats["Best Trade [%]"], 2),
            "Worst Trade [%]": round(stats["Worst Trade [%]"], 2),
            "Has FINAL_CLOSE": has_final_close,
            "Last Signal Log": last_log_str
        }

        results.append(result)

        # Equity, Return Îì±ÏùÄ ÏõêÍ∏à cash ÎåÄÎπÑ Ï¥ù ÏûêÏÇ∞ Î∞è ÏàòÏùµÎ•†ÏùÑ ÏùòÎØ∏
        print(stats)
        print("\n".join(str(log) for log in getattr(stats._strategy, "trade_logs", [])))
        # bt.plot()

        # Ïã†Ìò∏Î∞úÏÉù Ï¢ÖÎ™© ÌÖîÎ†àÍ∑∏Îû® ÏïåÎûåÏ∂îÍ∞Ä
        if not has_final_close and last_log['Date'].strftime('%Y-%m-%d') >= (datetime.datetime.today() - datetime.timedelta(days=1)).strftime("%Y-%m-%d") :
            report_text = (
                "=====================\n"
                f"üìä Ï¢ÖÎ™©Î™Ö: {name}\n"
                f"üí∞ ÏàòÏùµÎ•†: {round(stats["Return [%]"], 2):,}\n"
                f"üìå Buy & Hold: {round(stats["Buy & Hold Return [%]"], 2):,}\n"
                f"üìà ÎßàÏßÄÎßâÏã†Ìò∏: {last_log_str}\n"
            )

            # === üìâ Ï∞®Ìä∏ ÏÉùÏÑ± ===
            plt.figure(figsize=(10, 5))
            plt.plot(df['Close'], label='Close', color='black', linewidth=1.2)
            plt.title(f"{name} ({symbol}) - ÏµúÍ∑º Ï£ºÍ∞Ä Î∞è Ïã†Ìò∏")
            plt.xlabel("Date")
            plt.ylabel("Price ($)")
            plt.grid(True, linestyle="--", alpha=0.5)

            # BUY / SELL Ïã†Ìò∏ ÌëúÏãú
            if not trade_df.empty:
                buy_dates = trade_df[trade_df["Signal"] == "BUY"]["Date"]
                sell_dates = trade_df[trade_df["Signal"] == "SELL"]["Date"]
                plt.scatter(buy_dates, df.loc[buy_dates, "Close"], color="green", label="BUY", marker="^", s=80)
                plt.scatter(sell_dates, df.loc[sell_dates, "Close"], color="red", label="SELL", marker="v", s=80)

            plt.legend()
            plt.rcParams['font.family'] = 'Malgun Gothic'
            plt.rcParams['axes.unicode_minus'] = False

            # Î©îÎ™®Î¶¨ Î≤ÑÌçºÏóê Ï†ÄÏû• (ÌååÏùº Ïïà ÎßåÎì§Í≥† Î∞îÎ°ú ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ°Ïö©)
            buf = io.BytesIO()
            plt.savefig(buf, format='png', bbox_inches='tight')
            buf.seek(0)
            plt.close()

            send_telegram_message(BOT_TOKEN, CHAT_ID, report_text, photo=buf)

            buf.close()

    # ====== Í≤∞Í≥º ÏöîÏïΩÌëú ======
    summary_df = pd.DataFrame(results)
    print("\nüìä Ï†ÑÏ≤¥ Ï¢ÖÎ™© Í≤∞Í≥º ÏöîÏïΩ:")
    print(summary_df.to_string(index=False))




